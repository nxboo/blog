<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bin blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.boshu.org/"/>
  <updated>2017-03-05T07:24:31.000Z</updated>
  <id>http://blog.boshu.org/</id>
  
  <author>
    <name>Bin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql性能分析</title>
    <link href="http://blog.boshu.org/2017/02/mysql-explain/"/>
    <id>http://blog.boshu.org/2017/02/mysql-explain/</id>
    <published>2017-02-27T16:00:00.000Z</published>
    <updated>2017-03-05T07:24:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>#Mysql性能分析</p>
<p>执行mysql语句，只要在前面加上 explain 就可以分析查询语句的效率。</p>
<p>例如：</p>
<blockquote>
<p>explain select focus_uid from user_focus where uid = xxx;</p>
</blockquote>
<p>explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。</p>
<p>具体解释如下：</p>
<p>id 本次 select 的标识符。在查询中每个 select都有一个顺序的数值。<br>select_type select 的类型，可能会有以下几种：</p>
<ul>
<li>simple: 简单的 select （没有使用 union或子查询）</li>
<li>primary: 最外层的 select。</li>
<li>union: 第二层，在select 之后使用了 union。</li>
<li>dependent union: union 语句中的第二个select，依赖于外部子查询</li>
<li>subquery: 子查询中的第一个 select</li>
<li>dependent subquery: 子查询中的第一个 subquery依赖于外部的子查询</li>
<li>derived: 派生表 select（from子句中的子查询）</li>
</ul>
<p>table：显示这一行的数据是关于哪张表的<br>type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_ref、ref、range、index 和ALL<br>system:表只有一行记录（等于系统表）。这是 const表连接类型的一个特例。<br>const:表中最多只有一行匹配的记录，它在查询一开始的时候就会被读取出来。由于只有一行记录，在余下的优化程序里该行记录的字段值可以被当作是一个 恒定值。const表查询起来非常快，因为只要读取一次！const 用于在和 primary key 或unique 索引中有固定值比较的情形。下面的几个查询中，tbl_name 就是 c表了。<br>eq_ref:从该表中会有一行记录被读取出来以和从前一个表中读取出来的记录做联合。与const类型不同的是，这是最好的连接类型。它用在索引所有部 分都用于做连接并且这个索引是一个primary key 或 unique 类型。eq_ref可以用于在进行”=”做比较时检索字段。比较的值可以是固定值或者是表达式，表达示中可以使用表里的字段，它们在读表之前已经准备好 了。<br>ref: 该表中所有符合检索值的记录都会被取出来和从上一个表中取出来的记录作联合。ref用于连接程序使用键的最左前缀或者是该键不是 primary key 或 unique索引（换句话说，就是连接程序无法根据键值只取得一条记录）的情况。当根据键值只查询到少数几条匹配的记录时，这就是一个不错的连接类型。 ref还可以用于检索字段使用 =操作符来比较的时候。<br>ref_or_null: 这种连接类型类似 ref，不同的是mysql会在检索的时候额外的搜索包含null 值的记录。<br>range: 只有在给定范围的记录才会被取出来，利用索引来取得一条记录。key字段表示使用了哪个索引。key_len字段包括了使用的键的最长部分。这种类型时 ref 字段值是 null。range用于将某个字段和一个定植用以下任何操作符比较时 =, &lt;&gt;, &gt;,&gt;=, &lt;, &lt;=, is null, &lt;=&gt;, between, 或 in。<br>index: 连接类型跟 all 一样，不同的是它只扫描索引树。它通常会比 all快点，因为索引文件通常比数据文件小。mysql在查询的字段知识单独的索引的一部分的情况下使用这种连接类型。<br>all: 将对该表做全部扫描以和从前一个表中取得的记录作联合。这时候如果第一个表没有被标识为const的话就不大好了，在其他情况下通常是非常糟糕的。正常地，可以通过增加索引使得能从表中更快的取得记录以避免all。  </p>
<p>得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。  </p>
<p>possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句<br>key：    实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用force  INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引<br>key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好<br>ref：    显示索引的哪一列被使用了，如果可能的话，是一个常数<br>rows：   MYSQL认为必须检查的用来返回请求数据的行数<br>Extra：  关于MYSQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，结果是检索会很慢  </p>
<p>extra列返回的描述的意义<br>Distinct:一旦MYSQL找到了与行相联合匹配的行，就不再搜索了<br>Not exists: MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了<br>Range checked for each Record（index map:#）:没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一  </p>
<p>Using filesort: mysql需要额外的做一遍从而以排好的顺序取得记录。排序程序根据连接的类型遍历所有的记录，并且将所有符合 where条件的记录的要排序的键和指向记录的指针存储起来。这些键已经排完序了，对应的记录也会按照排好的顺序取出来。  </p>
<p>Using index: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候<br>using temporary: mysql需要创建临时表存储结果以完成查询。这种情况通常发生在查询时包含了groupby 和 order by 子句，它以不同的方式列出了各个字段。<br>using where</p>
<p>where子句将用来限制哪些记录匹配了下一个表或者发送给客户端。除非你特别地想要取得或者检查表种的所有记录，否则的话当查询的extra 字段值不是 using where 并且表连接类型是 all 或 index时可能表示有问题。  </p>
<p>如果你想要让查询尽可能的快，那么就应该注意 extra 字段的值为usingfilesort 和 using temporary 的情况。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#Mysql性能分析&lt;/p&gt;
&lt;p&gt;执行mysql语句，只要在前面加上 explain 就可以分析查询语句的效率。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;explain select focus_uid from user_focus where u
    
    </summary>
    
    
      <category term="mysql" scheme="http://blog.boshu.org/tags/mysql/"/>
    
      <category term="性能" scheme="http://blog.boshu.org/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>nginx fastcgi cache</title>
    <link href="http://blog.boshu.org/2017/02/nginx-cache/"/>
    <id>http://blog.boshu.org/2017/02/nginx-cache/</id>
    <published>2017-02-27T16:00:00.000Z</published>
    <updated>2017-03-05T08:18:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h1><h2 id="fastcgi-cache-path"><a href="#fastcgi-cache-path" class="headerlink" title="fastcgi_cache_path"></a>fastcgi_cache_path</h2><blockquote>
<p>syntax: fastcgi_cache_path path [ levels = levels ] keys_zone = name : size [ inactive = time ] [ max_size = size ] [ loader_files = number ] [ &gt; loader_sleep = time ] [ loader_threshold = time ]<br>default: none<br>context: http</p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">fastcgi_cache_path</span> /dev/shm/nginx_cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=fcgicache:<span class="number">10m</span> inactive=<span class="number">50m</span> max_size=<span class="number">128m</span>;</div></pre></td></tr></table></figure>
<ul>
<li>/tmp/nginx/fcgi/cache 缓存目录</li>
<li>keys_zone=fcgicache:10m keys_zone是这个缓存空间的名字，10m是用多少内存（主要缓存key和文件元信息，不会缓存页面）,这个会在fastcgi_cache中引用</li>
<li>levels=1:2 设置目录哈希层级，比如2:2会生成256*256个字目录</li>
<li>inactive 失效时间</li>
<li>max_size 最多用多少空间</li>
</ul>
<h2 id="fastcgi-temp-path"><a href="#fastcgi-temp-path" class="headerlink" title="fastcgi_temp_path"></a>fastcgi_temp_path</h2><blockquote>
<p>Syntax:    fastcgi_temp_path path [ level1 [ level2 [ level3 ]]]<br>Default:    fastcgi_temp<br>Context:    http server location</p>
</blockquote>
<p>生成fastcgi_cache临时文件目录，fastcgi_cache缓存是先写在fastcgi_temp_path再移到fastcgi_cache_path，所以这两个目录最好在同一个分区，从0.8.9之后可以在不同的分区，不过还是建议放同一分区</p>
<h2 id="fastcgi-cache"><a href="#fastcgi-cache" class="headerlink" title="fastcgi_cache"></a>fastcgi_cache</h2><blockquote>
<p>Syntax:    fastcgi_cache zone | off;<br>Default: off;<br>Context:    http, server, location</p>
</blockquote>
<p>用哪个缓存空间，fastcgi_cache_path定义</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">fastcgi_cache</span> fcgicache;</div></pre></td></tr></table></figure>
<blockquote>
<p>Syntax:    fastcgi_cache_key string;<br>Default:    —<br>Context:    http, server, location</p>
</blockquote>
<p>设置缓存的key<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">fastcgi_cache_key</span> <span class="string">"<span class="variable">$scheme</span><span class="variable">$request_method</span><span class="variable">$host</span><span class="variable">$request_uri</span>"</span>;</div></pre></td></tr></table></figure></p>
<p>建议：在http层定义一个，如果在server或location要修改的必要，再进行修改</p>
<h2 id="fastcgi-cache-methods"><a href="#fastcgi-cache-methods" class="headerlink" title="fastcgi_cache_methods"></a>fastcgi_cache_methods</h2><blockquote>
<p>Syntax:      fastcgi_cache_methods GET | HEAD | POST …;<br>Default:  GET HEAD;<br>Context:  http, server, location</p>
</blockquote>
<p>允许缓存的请求类型</p>
<h2 id="fastcgi-cache-min-uses"><a href="#fastcgi-cache-min-uses" class="headerlink" title="fastcgi_cache_min_uses"></a>fastcgi_cache_min_uses</h2><blockquote>
<p>Syntax:    fastcgi_cache_min_uses number;<br>Default:  1;<br>Context:    http, server, location</p>
</blockquote>
<p>最少要被请求多少次才会缓存</p>
<h2 id="fastcgi-cache-use-stale"><a href="#fastcgi-cache-use-stale" class="headerlink" title="fastcgi_cache_use_stale"></a>fastcgi_cache_use_stale</h2><blockquote>
<p>syntax: fastcgi_cache_use_stale [error | timeout | invalid_header | updating | http_500 | http_503 | http_403 | http_404 | off]<br>default: fastcgi_cache_use_stale off;<br>context: http, server, location</p>
</blockquote>
<p>定义哪些情况下用过期缓存<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">fastcgi_cache_use_stale</span> <span class="literal">error</span> timeout invalid_header http_500 http_503 updating;</div></pre></td></tr></table></figure></p>
<h2 id="fastcgi-cache-valid"><a href="#fastcgi-cache-valid" class="headerlink" title="fastcgi_cache_valid"></a>fastcgi_cache_valid</h2><blockquote>
<p>Syntax:    fastcgi_cache_valid [code …] time;<br>Default:    —<br>Context:    http, server, location</p>
</blockquote>
<p>针对不同的状态，设置不同的缓存时间，可多行<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">fastcgi_cache_valid</span> <span class="number">200</span> <span class="number">302</span>  <span class="number">10m</span>;</div><div class="line"><span class="attribute">fastcgi_cache_valid</span> <span class="number">301</span>      <span class="number">1h</span>;</div><div class="line"><span class="attribute">fastcgi_cache_valid</span> any      <span class="number">1m</span>;</div><div class="line"><span class="attribute">fastcgi_cache_valid</span> <span class="number">1m</span>;  <span class="comment">#等同于 fastcgi_cache_valid 200 301 302 1m;</span></div></pre></td></tr></table></figure></p>
<h1 id="在响应头中设置缓存时间"><a href="#在响应头中设置缓存时间" class="headerlink" title="在响应头中设置缓存时间"></a>在响应头中设置缓存时间</h1><p>缓存的参数也可以直接在响应头中设置。这比使用指令设置缓存时间具有更高的优先级。</p>
<ul>
<li>“X-Accel-Expires”标头字段设置响应的缓存时间（以秒为单位）。零禁用缓存。如果值以@前缀开始，则它设置以当前时间开始的以秒为单位的绝对时间，直到响应可以被缓存。</li>
<li>如果报头不包括“X-Accel-Expires”字段，则可以在报头字段“Expires”或“Cache-Control”中设置高速缓存的参数。</li>
<li>如果头包括“Set-Cookie”字段，则这样的响应将不被缓存。</li>
<li>如果头中Vary *，则这样的响应将不被缓存（1.7.7）。如果报头包括具有另一个值的“Vary”字段，则这样的响应将被缓存，考虑相应的请求报头字段（1.7.7）。</li>
</ul>
<h1 id="为什么没有被缓存？"><a href="#为什么没有被缓存？" class="headerlink" title="为什么没有被缓存？"></a>为什么没有被缓存？</h1><ul>
<li>Nginx fastcgi_cache在缓存后端fastcgi响应时，当响应里包含“set-cookie”时，不缓存;</li>
<li>当响应头包含Expires时，如果过期时间大于当前服务器时间，则nginx_cache会缓存该响应，否则，则不缓存;</li>
<li>当响应头包含Cache-Control时，如果Cache-Control参数值为no-cache、no-store、private中任意一个时，则不缓存</li>
<li>头中Vary * (1.7.7)</li>
</ul>
<p>可以使用fastcgi_ignore_headers指令禁用对这些响应头字段中的一个或多个的处理。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">fastcgi_ignore_headers</span> Expires Cache-Control;</div><div class="line"><span class="attribute">fastcgi_ignore_headers</span> Set-Cookie; <span class="comment">#如果加入这条，则后端无法设置cookie,session</span></div></pre></td></tr></table></figure>
<h1 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h1><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">http&#123;</div><div class="line">  #...</div><div class="line">  fastcgi_cache_path /dev/shm/nginx_cache levels=1:2 keys_zone=fcgicache:10m inactive=30m max_size=128m;</div><div class="line">  fastcgi_cache_key  "$scheme$request_method$host$request_uri";</div><div class="line">  fastcgi_temp_path  /dev/shm/nginx_tmp;</div><div class="line">  #...</div><div class="line"></div><div class="line">  server&#123;</div><div class="line">    #...</div><div class="line">    location ~ \.php($|/) &#123;</div><div class="line">        #...</div><div class="line">        fastcgi_cache fcgicache; #用哪个缓存空间</div><div class="line">        fastcgi_cache_valid 1m; #200 301 302缓存1分钟</div><div class="line">        fastcgi_cache_valid 404 500 502 503 504 0s; #404 500 502 503 504不缓存</div><div class="line">        fastcgi_cache_valid any 3h; #其它缓存3小时</div><div class="line">        fastcgi_cache_min_uses 1; #经过一次请求后缓存</div><div class="line">        fastcgi_cache_use_stale error timeout invalid_header http_500 http_503 updating; #哪些情况下用过期缓存</div><div class="line">        fastcgi_ignore_headers Expires Cache-Control; #忽略Expires Cache-Control头</div><div class="line">        #...</div><div class="line">    &#125;</div><div class="line">    #...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><ul>
<li>$upstream_response_time为过期时间</li>
<li>$upstream_cache_status 表示此请求响应来自cache的状态</li>
</ul>
<h2 id="缓存状态："><a href="#缓存状态：" class="headerlink" title="缓存状态："></a>缓存状态：</h2><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>MISS</td>
<td>未命中</td>
</tr>
<tr>
<td>EXPIRED</td>
<td>expired, request was passed to backend Cache已过期</td>
</tr>
<tr>
<td>UPDATING</td>
<td>expired, stale response was used due to proxy/fastcgi_cache_use_stale updating Cache已过期，(被其他nginx子进程)更新中</td>
</tr>
<tr>
<td>STALE</td>
<td>expired, stale response was used due to proxy/fastcgi_cache_use_stale Cache已过期，响应数据不合法，被污染HIT 命中cache</td>
</tr>
</tbody>
</table>
<h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><p>逐个测试，测试时，注释其他的<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">header(<span class="string">"Expires: "</span>.gmdate(<span class="string">"D, d M Y H:i:s"</span>, time()+<span class="number">10000</span>).<span class="string">' GMT'</span>);</div><div class="line">header(<span class="string">"Expires: "</span>.gmdate(<span class="string">"D, d M Y H:i:s"</span>, time()<span class="number">-99999</span>).<span class="string">' GMT'</span>);</div><div class="line">header(<span class="string">"X-Accel-Expires:5"</span>); <span class="comment">// 5s</span></div><div class="line">header(<span class="string">"Cache-Control: no-cache"</span>); <span class="comment">//no cache</span></div><div class="line">header(<span class="string">"Cache-Control: no-store"</span>); <span class="comment">//no cache</span></div><div class="line">header(<span class="string">"Cache-Control: private"</span>); <span class="comment">//no cache</span></div><div class="line">header(<span class="string">"Cache-Control: max-age=10"</span>); <span class="comment">//cache 10s</span></div><div class="line">setcookie(<span class="string">'hello'</span>,<span class="string">"testaaaa"</span>); <span class="comment">//no cache</span></div><div class="line"><span class="keyword">echo</span> date(<span class="string">"Y-m-d H:i:s"</span>,time());</div><div class="line"><span class="keyword">exit</span>;</div></pre></td></tr></table></figure></p>
<p>程序调用session_start时，php的session拓展自己输出的。session.cache_limit参数来决定输出包含哪种Expires的header，默认是nocache，修改php.ini的session.cache_limit参数为“none”即可让session模块不再输出这些http 响应头。或在调用session_start之前，使用session_cache_limiter函数来指定下该参数值。那为什么要在使用session时，发Expires、Cache-Control的http response header呢？我猜测了下，需要session时，基本上是用户跟服务器有交互，那么，既然有交互，就意味着用户的每次交互结果也可能不一样，就不能cache这个请求的结果，给返回给这个用户。同时，每个用户的交互结果都是不一样的，nginx也就不能把包含特殊Cache-Control的个人响应cache给其他人提供了。  </p>
<p>非要用session_start 可以如下方式</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">session_cache_limiter(<span class="string">"none"</span>);</div><div class="line">session_start();</div><div class="line"><span class="keyword">echo</span> date(<span class="string">"Y-m-d H:i:s"</span>,time());</div><div class="line"><span class="keyword">exit</span>;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;相关参数&quot;&gt;&lt;a href=&quot;#相关参数&quot; class=&quot;headerlink&quot; title=&quot;相关参数&quot;&gt;&lt;/a&gt;相关参数&lt;/h1&gt;&lt;h2 id=&quot;fastcgi-cache-path&quot;&gt;&lt;a href=&quot;#fastcgi-cache-path&quot; class=&quot;
    
    </summary>
    
    
      <category term="nginx" scheme="http://blog.boshu.org/tags/nginx/"/>
    
      <category term="cache" scheme="http://blog.boshu.org/tags/cache/"/>
    
  </entry>
  
</feed>
